/*Control turtlebot tp move from start location to the goal location.*/
/*Objects
    % memory banks
    E_k
    e_k_1
    
    % gains
    Kp
    Ki
    Kd
    
    % time step
    delta_t

    % plot support
    p

    % maximum v, and w
    v_max
    w_max
*/


// Get start and goal position(x,y,theta) of turtlebot. Use the vicon system to get the global lacation.



// update the current position(x,y,theta) of turtlebot. Use the vicon system to get the global lacation.



// Set minimum time step



// Control input (v,w) publisher

/*

Matlab code:
        function outputs = execute(obj, robot, state_estimate, inputs, dt)
        %% EXECUTE Computes the left and right wheel speeds for go-to-goal.
        %   [v, w] = execute(obj, robot, x_g, y_g, v) will compute the
        %   necessary linear and angular speeds that will steer the robot
        %   to the goal location (x_g, y_g) with a constant linear velocity
        %   of v.
        %
        %   See also controller/execute
        
            % Retrieve the (relative) goal location, from vicon system, 
            x_g = inputs.x_g; 
            y_g = inputs.y_g;
            
            % Get estimate of current pose, use /odom info or use current pos info from vicon system
            [x, y, theta] = state_estimate.unpack();
            
            % Compute the v,w that will get you to the goal, set as a constant
            v = inputs.v;
            
            % 1. Calculate the heading (angle) to the goal.
            
            % distance between goal and robot in x-direction
            u_x = x_g - x;     
                
            % distance between goal and robot in y-direction
            u_y = y_g - y;
                
            % angle from robot to goal. Hint: use ATAN2, u_x, u_y here.
            theta_g = atan2(u_y, u_x);
            
            % 2. Calculate the heading error.
            
            % error between the goal angle and robot's angle
            % Hint: Use ATAN2 to make sure this stays in [-pi,pi].
            alpha = theta_g - theta;
            e_k = atan2(sin(alpha),cos(alpha)); 
            %e_k = theta_g - theta;
                
            % 3. Calculate PID for the steering angle 
            
            % error for the proportional term
            e_P = e_k;
            
            
            % error for the integral term. Hint: Approximate the integral using
            % the accumulated error, obj.E_k, and the error for
            % this time step, e_k.
            e_I = e_k + obj.E_k;
                     
            % error for the derivative term. Hint: Approximate the derivative
            % using the previous error, obj.e_k_1, and the
            % error for this time step, e_k.
            e_D = e_k - obj.e_k_1;    
                  
            w = obj.Kp*e_P + obj.Ki*e_I + obj.Kd*e_D;
            
            % 4. Save errors for next time step
            obj.E_k = e_I;
            obj.e_k_1 = e_k;
            
            % plot
            obj.p.plot_2d_ref(dt, atan2(sin(theta),cos(theta)), theta_g, 'r');
            
            outputs = obj.outputs;  % make a copy of the output struct
            outputs.v = v;
            outputs.w = w;
        end
        
    end
    
end
*/
// Stop tuetlebot when the goal location was achieved

To reset simulation gazebo:
rosservice call /gazebo/reset_simulation "{}"

To reset odom info:
rostopic pub /mobile_base/commands/reset_odometry std_msgs/Empty

To launch an empty gazebo world:
roslaunch turtlebot_gazebo turtlebot_world.launch world_file:=/home/han/catkin_ws/src/turtlebot_simulator/turtlebot_gazebo/worlds/empty.world


// ROS_INFO("roll, pitch, yaw=%1.2f  %1.2f  %1.2f", roll, pitch, yaw);


